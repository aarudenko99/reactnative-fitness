'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeConfigJsonAsync = exports.readConfigJsonAsync = exports.validateShortName = exports.readExpRcAsync = exports.configFilenameAsync = exports.findConfigFileAsync = exports.fileExistsAsync = exports.addPlatform = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

let addPlatform = exports.addPlatform = (() => {
  var _ref = (0, _asyncToGenerator3.default)(function* (projectRoot, platform) {
    var _ref2 = yield readConfigJsonAsync(projectRoot);

    const exp = _ref2.exp;


    let currentPlatforms = [];
    if (Array.isArray(exp.platforms) && exp.platforms.length) {
      currentPlatforms = exp.platforms;
    }
    if (currentPlatforms.includes(platform)) {
      return;
    }

    return yield writeConfigJsonAsync(projectRoot, { platforms: [...currentPlatforms, platform] });
  });

  return function addPlatform(_x, _x2) {
    return _ref.apply(this, arguments);
  };
})();

let fileExistsAsync = exports.fileExistsAsync = (() => {
  var _ref3 = (0, _asyncToGenerator3.default)(function* (file) {
    try {
      return (yield _fsExtra2.default.stat(file)).isFile();
    } catch (e) {
      return false;
    }
  });

  return function fileExistsAsync(_x3) {
    return _ref3.apply(this, arguments);
  };
})();

let _findConfigPathAsync = (() => {
  var _ref4 = (0, _asyncToGenerator3.default)(function* (projectRoot) {
    const appJson = _path2.default.join(projectRoot, APP_JSON_FILE_NAME);
    const expJson = _path2.default.join(projectRoot, EXP_JSON_FILE_NAME);
    if (yield fileExistsAsync(appJson)) {
      return appJson;
    } else if (yield fileExistsAsync(expJson)) {
      return expJson;
    } else {
      return appJson;
    }
  });

  return function _findConfigPathAsync(_x4) {
    return _ref4.apply(this, arguments);
  };
})();

let findConfigFileAsync = exports.findConfigFileAsync = (() => {
  var _ref5 = (0, _asyncToGenerator3.default)(function* (projectRoot) {
    let configPath;
    if (customConfigPaths[projectRoot]) {
      configPath = customConfigPaths[projectRoot];
    } else {
      configPath = yield _findConfigPathAsync(projectRoot);
    }
    return getConfigPaths(configPath);
  });

  return function findConfigFileAsync(_x5) {
    return _ref5.apply(this, arguments);
  };
})();

let configFilenameAsync = exports.configFilenameAsync = (() => {
  var _ref6 = (0, _asyncToGenerator3.default)(function* (projectRoot) {
    return (yield findConfigFileAsync(projectRoot)).configName;
  });

  return function configFilenameAsync(_x6) {
    return _ref6.apply(this, arguments);
  };
})();

let readExpRcAsync = exports.readExpRcAsync = (() => {
  var _ref7 = (0, _asyncToGenerator3.default)(function* (projectRoot) {
    const expRcPath = _path2.default.join(projectRoot, '.exprc');

    if (!_fsExtra2.default.existsSync(expRcPath)) {
      return {};
    }

    try {
      return yield _jsonFile2.default.readAsync(expRcPath, { json5: true });
    } catch (e) {
      throw new Error(`Failed to parse JSON file: ${e.toString()}`);
    }
  });

  return function readExpRcAsync(_x7) {
    return _ref7.apply(this, arguments);
  };
})();

let validateShortName = exports.validateShortName = (() => {
  var _ref8 = (0, _asyncToGenerator3.default)(function* (shortName) {
    // Validate short name
    if (shortName.length > MAX_SHORT_NAME_LENGTH) {
      console.warn(`PWA short name should be 12 characters or less, otherwise it'll be curtailed on the mobile device homepage. You should define web.shortName in your ${APP_JSON_FILE_NAME} as a string that is ${MAX_SHORT_NAME_LENGTH} or less characters.`);
    }
  });

  return function validateShortName(_x8) {
    return _ref8.apply(this, arguments);
  };
})();

// Convert expo value to PWA value


let readConfigJsonAsync = exports.readConfigJsonAsync = (() => {
  var _ref9 = (0, _asyncToGenerator3.default)(function* (projectRoot) {
    let exp;
    let pkg;
    let rootConfig;

    var _ref10 = yield findConfigFileAsync(projectRoot);

    const configPath = _ref10.configPath,
          configName = _ref10.configName,
          configNamespace = _ref10.configNamespace;


    try {
      exp = yield _jsonFile2.default.readAsync(configPath, { json5: true });

      if (configNamespace) {
        // if we're not using exp.json, then we've stashed everything under an expo key
        rootConfig = exp;
        exp = exp[configNamespace];
      }
    } catch (e) {
      if (e.code === 'ENOENT') {
        // config missing. might be in package.json
      } else if (e.isJsonFileError) {
        throw e;
      }
    }

    try {
      const packageJsonPath = exp && exp.nodeModulesPath ? _path2.default.join(_path2.default.resolve(projectRoot, exp.nodeModulesPath), 'package.json') : _path2.default.join(projectRoot, 'package.json');
      pkg = yield _jsonFile2.default.readAsync(packageJsonPath);
    } catch (e) {
      if (e.isJsonFileError) {
        throw e;
      }

      // pkg missing
    }

    // Easiest bail-out: package.json is missing
    if (!pkg) {
      throw new Error(`Can't find package.json`);
    }

    // Grab our exp config from package.json (legacy) or exp.json
    if (!exp && pkg.exp) {
      exp = pkg.exp;
      throw new Error(`Move your "exp" config from package.json to ${APP_JSON_FILE_NAME}.`);
    } else if (!exp && !pkg.exp) {
      throw new Error(`Missing ${configName}. See https://docs.expo.io/`);
    }

    // fill any required fields we might care about

    // TODO(adam) decide if there are other fields we want to provide defaults for

    if (exp && !exp.name) {
      exp.name = pkg.name;
    }

    if (exp && !exp.slug) {
      exp.slug = (0, _slugify2.default)(exp.name.toLowerCase());
    }

    if (exp && !exp.version) {
      exp.version = pkg.version;
    }

    if (exp && !exp.platforms) {
      exp.platforms = ['android', 'ios'];
    }

    if (exp.nodeModulesPath) {
      exp.nodeModulesPath = _path2.default.resolve(projectRoot, exp.nodeModulesPath);
    }

    return { exp, pkg, rootConfig };
  });

  return function readConfigJsonAsync(_x9) {
    return _ref9.apply(this, arguments);
  };
})();

let writeConfigJsonAsync = exports.writeConfigJsonAsync = (() => {
  var _ref11 = (0, _asyncToGenerator3.default)(function* (projectRoot, options) {
    var _ref12 = yield findConfigFileAsync(projectRoot);

    const configName = _ref12.configName,
          configPath = _ref12.configPath,
          configNamespace = _ref12.configNamespace;

    var _ref13 = yield readConfigJsonAsync(projectRoot);

    let exp = _ref13.exp,
        pkg = _ref13.pkg,
        rootConfig = _ref13.rootConfig;

    let config = rootConfig || {};

    if (!exp) {
      throw new Error(`Couldn't read ${configName}`);
    }
    if (!pkg) {
      throw new Error(`Couldn't read package.json`);
    }

    exp = (0, _extends3.default)({}, exp, options);

    if (configNamespace) {
      config[configNamespace] = exp;
    } else {
      config = exp;
    }

    yield _jsonFile2.default.writeAsync(configPath, config, { json5: false });

    return {
      exp,
      pkg,
      rootConfig
    };
  });

  return function writeConfigJsonAsync(_x10, _x11) {
    return _ref11.apply(this, arguments);
  };
})();

exports.isUsingYarn = isUsingYarn;
exports.fileExists = fileExists;
exports.resolveModule = resolveModule;
exports.findConfigFile = findConfigFile;
exports.configFilename = configFilename;
exports.setCustomConfigPath = setCustomConfigPath;
exports.createEnvironmentConstants = createEnvironmentConstants;
exports.getConfigForPWA = getConfigForPWA;
exports.getNameFromConfig = getNameFromConfig;
exports.ensurePWAConfig = ensurePWAConfig;
exports.readConfigJson = readConfigJson;

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _jsonFile = require('@expo/json-file');

var _jsonFile2 = _interopRequireDefault(_jsonFile);

var _resolveFrom = require('resolve-from');

var _resolveFrom2 = _interopRequireDefault(_resolveFrom);

var _slugify = require('slugify');

var _slugify2 = _interopRequireDefault(_slugify);

var _findYarnWorkspaceRoot = require('find-yarn-workspace-root');

var _findYarnWorkspaceRoot2 = _interopRequireDefault(_findYarnWorkspaceRoot);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let hasWarnedAboutExpJson = false;

const EXP_JSON_FILE_NAME = 'exp.json';
const APP_JSON_FILE_NAME = 'app.json';

// To work with the iPhone X "notch" add `viewport-fit=cover` to the `viewport` meta tag.
const DEFAULT_VIEWPORT = 'width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1.00001,viewport-fit=cover';
// Use root to work better with create-react-app
const DEFAULT_ROOT_ID = `root`;
const DEFAULT_BUILD_PATH = `web-build`;
const DEFAULT_LANGUAGE_ISO_CODE = `en`;
const DEFAULT_NO_JS_MESSAGE = `Oh no! It looks like JavaScript is not enabled in your browser.`;
const DEFAULT_NAME = 'Expo App';
const DEFAULT_THEME_COLOR = '#4630EB';
const DEFAULT_DESCRIPTION = 'A Neat Expo App';
const DEFAULT_BACKGROUND_COLOR = '#ffffff';
const DEFAULT_START_URL = '.';
const DEFAULT_DISPLAY = 'standalone';
const DEFAULT_STATUS_BAR = 'default';
const DEFAULT_LANG_DIR = 'auto';
const DEFAULT_ORIENTATION = 'any';
const ICON_SIZES = [192, 512];
const MAX_SHORT_NAME_LENGTH = 12;
const DEFAULT_PREFER_RELATED_APPLICATIONS = true;

function isUsingYarn(projectRoot) {
  const workspaceRoot = (0, _findYarnWorkspaceRoot2.default)(projectRoot);
  if (workspaceRoot) {
    return _fsExtra2.default.existsSync(_path2.default.join(workspaceRoot, 'yarn.lock'));
  } else {
    return _fsExtra2.default.existsSync(_path2.default.join(projectRoot, 'yarn.lock'));
  }
}

function fileExists(file) {
  try {
    return _fsExtra2.default.statSync(file).isFile();
  } catch (e) {
    return false;
  }
}

function resolveModule(request, projectRoot, exp) {
  const fromDir = exp.nodeModulesPath ? exp.nodeModulesPath : projectRoot;
  return (0, _resolveFrom2.default)(fromDir, request);
}

function _findConfigPath(projectRoot) {
  const appJson = _path2.default.join(projectRoot, APP_JSON_FILE_NAME);
  const expJson = _path2.default.join(projectRoot, EXP_JSON_FILE_NAME);
  if (fileExists(appJson)) {
    return appJson;
  } else if (fileExists(expJson)) {
    return expJson;
  } else {
    return appJson;
  }
}

function findConfigFile(projectRoot) {
  let configPath;
  if (customConfigPaths[projectRoot]) {
    configPath = customConfigPaths[projectRoot];
  } else {
    configPath = _findConfigPath(projectRoot);
  }
  return getConfigPaths(configPath);
}

function getConfigPaths(configPath) {
  const configName = _path2.default.basename(configPath);
  const configNamespace = configName !== EXP_JSON_FILE_NAME ? 'expo' : null;

  guardConfigName(configName);

  return { configPath, configName, configNamespace };
}

function guardConfigName(configName) {
  if (configName === EXP_JSON_FILE_NAME && !hasWarnedAboutExpJson) {
    hasWarnedAboutExpJson = true;
    throw new Error(`configuration using ${EXP_JSON_FILE_NAME} is deprecated.
    Please move your configuration from ${EXP_JSON_FILE_NAME} to ${APP_JSON_FILE_NAME}.
    Example ${APP_JSON_FILE_NAME}:
    {
      "expo": {
        (JSON contents from ${EXP_JSON_FILE_NAME})
      }
    }`);
  }
}

function configFilename(projectRoot) {
  return findConfigFile(projectRoot).configName;
}

let customConfigPaths = {};

function setCustomConfigPath(projectRoot, configPath) {
  customConfigPaths[projectRoot] = configPath;
}

function createEnvironmentConstants(appManifest, pwaManifestLocation) {
  let web;
  try {
    web = require(pwaManifestLocation);
  } catch (e) {
    web = {};
  }

  // TODO: Bacon: use web values here
  return {
    /**
     * Omit app.json properties that get removed during the native turtle build
     *
     * `facebookScheme`
     * `facebookAppId`
     * `facebookDisplayName`
     */
    name: appManifest.displayName || appManifest.name,
    description: appManifest.description,
    slug: appManifest.slug,
    sdkVersion: appManifest.sdkVersion,
    version: appManifest.version,
    githubUrl: appManifest.githubUrl,
    orientation: appManifest.orientation,
    primaryColor: appManifest.primaryColor,
    privacy: appManifest.privacy,
    icon: appManifest.icon,
    scheme: appManifest.scheme,
    notification: appManifest.notification,
    splash: appManifest.splash,
    androidShowExponentNotificationInShellApp: appManifest.androidShowExponentNotificationInShellApp,
    web
  };
}

function sanitizePublicPath(publicPath) {
  if (typeof publicPath !== 'string' || !publicPath.length) {
    return '/';
  }

  if (publicPath.endsWith('/')) {
    return publicPath;
  }
  return publicPath + '/';
}

function getConfigForPWA(projectRoot, getAbsolutePath, options) {
  const config = readConfigJson(projectRoot);
  return ensurePWAConfig(config, getAbsolutePath, options);
}
function getNameFromConfig(exp = {}) {
  // For RN CLI support
  const appManifest = exp.expo || exp;
  var _appManifest$web = appManifest.web;
  const web = _appManifest$web === undefined ? {} : _appManifest$web;

  // rn-cli apps use a displayName value as well.

  const appName = exp.displayName || appManifest.displayName || appManifest.name || DEFAULT_NAME;
  const webName = web.name || appName;

  return {
    appName,
    webName
  };
}

function ensurePWAorientation(orientation) {
  if (orientation && typeof orientation === 'string') {
    let webOrientation = orientation.toLowerCase();
    if (webOrientation !== 'default') {
      return webOrientation;
    }
  }
  return DEFAULT_ORIENTATION;
}

function applyWebDefaults(appJSON) {
  // For RN CLI support
  const appManifest = appJSON.expo || appJSON;
  var _appManifest$web2 = appManifest.web;
  const webManifest = _appManifest$web2 === undefined ? {} : _appManifest$web2;
  var _appManifest$splash = appManifest.splash;
  const splash = _appManifest$splash === undefined ? {} : _appManifest$splash;
  var _appManifest$ios = appManifest.ios;
  const ios = _appManifest$ios === undefined ? {} : _appManifest$ios;
  var _appManifest$android = appManifest.android;
  const android = _appManifest$android === undefined ? {} : _appManifest$android;
  var _webManifest$build = webManifest.build;
  const webBuild = _webManifest$build === undefined ? {} : _webManifest$build;
  var _webManifest$webDange = webManifest.webDangerous;
  const webDangerous = _webManifest$webDange === undefined ? {} : _webManifest$webDange;
  var _webManifest$meta = webManifest.meta;
  const meta = _webManifest$meta === undefined ? {} : _webManifest$meta;
  var _meta$apple = meta.apple;
  const apple = _meta$apple === undefined ? {} : _meta$apple;

  // rn-cli apps use a displayName value as well.

  var _getNameFromConfig = getNameFromConfig(appJSON);

  const appName = _getNameFromConfig.name,
        webName = _getNameFromConfig.webName;


  const languageISOCode = webManifest.lang || DEFAULT_LANGUAGE_ISO_CODE;
  const noJavaScriptMessage = webDangerous.noJavaScriptMessage || DEFAULT_NO_JS_MESSAGE;
  const rootId = webBuild.rootId || DEFAULT_ROOT_ID;
  const buildOutputPath = webBuild.output || DEFAULT_BUILD_PATH;
  const publicPath = sanitizePublicPath(webManifest.publicPath);
  const primaryColor = appManifest.primaryColor || DEFAULT_THEME_COLOR;
  const description = appManifest.description || DEFAULT_DESCRIPTION;
  // The theme_color sets the color of the tool bar, and may be reflected in the app's preview in task switchers.
  const webThemeColor = webManifest.themeColor || primaryColor;
  const dir = webManifest.dir || DEFAULT_LANG_DIR;
  const shortName = webManifest.shortName || webName;
  const display = webManifest.display || DEFAULT_DISPLAY;
  const startUrl = webManifest.startUrl || DEFAULT_START_URL;
  const webViewport = meta.viewport || DEFAULT_VIEWPORT;
  const scope = webManifest.scope,
        crossorigin = webManifest.crossorigin;

  const barStyle = apple.barStyle || webManifest.barStyle || DEFAULT_STATUS_BAR;

  const orientation = ensurePWAorientation(webManifest.orientation || appManifest.orientation);

  /**
   * **Splash screen background color**
   * `https://developers.google.com/web/fundamentals/web-app-manifest/#splash-screen`
   * The background_color should be the same color as the load page,
   * to provide a smooth transition from the splash screen to your app.
   */
  const backgroundColor = webManifest.backgroundColor || splash.backgroundColor || DEFAULT_BACKGROUND_COLOR; // No default background color

  /**
   *
   * https://developer.mozilla.org/en-US/docs/Web/Manifest#prefer_related_applications
   * Specifies a boolean value that hints for the user agent to indicate
   * to the user that the specified native applications (see below) are recommended over the website.
   * This should only be used if the related native apps really do offer something that the website can't... like Expo ;)
   *
   * >> The banner won't show up if the app is already installed:
   * https://github.com/GoogleChrome/samples/issues/384#issuecomment-326387680
   */

  const preferRelatedApplications = webManifest.preferRelatedApplications || DEFAULT_PREFER_RELATED_APPLICATIONS;

  const relatedApplications = inferWebRelatedApplicationsFromConfig(appManifest);

  return (0, _extends3.default)({}, appManifest, {
    name: appName,
    description,
    primaryColor,
    // Ensure these objects exist
    ios: (0, _extends3.default)({}, ios),
    android: (0, _extends3.default)({}, android),
    web: (0, _extends3.default)({}, webManifest, {
      meta: (0, _extends3.default)({}, meta, {
        apple: (0, _extends3.default)({}, apple, {
          formatDetection: apple.formatDetection || 'telephone=no',
          mobileWebAppCapable: apple.mobileWebAppCapable || 'yes',
          touchFullscreen: apple.touchFullscreen || 'yes',
          barStyle
        }),
        viewport: webViewport
      }),
      build: (0, _extends3.default)({}, webBuild, {
        output: buildOutputPath,
        rootId,
        publicPath
      }),
      dangerous: (0, _extends3.default)({}, webDangerous, {
        noJavaScriptMessage
      }),
      scope,
      crossorigin,
      description,
      preferRelatedApplications,
      relatedApplications,
      startUrl,
      shortName,
      display,
      orientation,
      dir,
      barStyle,
      backgroundColor,
      themeColor: webThemeColor,
      lang: languageISOCode,
      name: webName
    })
  });
}

/**
 * https://developer.mozilla.org/en-US/docs/Web/Manifest#related_applications
 * An array of native applications that are installable by, or accessible to, the underlying platform
 * for example, a native Android application obtainable through the Google Play Store.
 * Such applications are intended to be alternatives to the
 * website that provides similar/equivalent functionality — like the native app version of the website.
 */
function inferWebRelatedApplicationsFromConfig({ web = {}, ios = {}, android = {} }) {
  const relatedApplications = web.relatedApplications || [];

  const bundleIdentifier = ios.bundleIdentifier,
        appStoreUrl = ios.appStoreUrl;

  if (bundleIdentifier) {
    const PLATFORM_ITUNES = 'itunes';
    let iosApp = relatedApplications.some(({ platform }) => platform === PLATFORM_ITUNES);
    if (!iosApp) {
      relatedApplications.push({
        platform: PLATFORM_ITUNES,
        url: appStoreUrl,
        id: bundleIdentifier
      });
    }
  }

  const androidPackage = android.package,
        playStoreUrl = android.playStoreUrl;

  if (androidPackage) {
    const PLATFORM_PLAY = 'play';

    const alreadyHasAndroidApp = relatedApplications.some(({ platform }) => platform === PLATFORM_PLAY);
    if (!alreadyHasAndroidApp) {
      relatedApplications.push({
        platform: PLATFORM_PLAY,
        url: playStoreUrl || `http://play.google.com/store/apps/details?id=${androidPackage}`,
        id: androidPackage
      });
    }
  }

  return relatedApplications;
}

function inferWebHomescreenIcons(config = {}, getAbsolutePath, options) {
  var _config$web = config.web;
  const web = _config$web === undefined ? {} : _config$web;
  var _config$ios = config.ios;
  const ios = _config$ios === undefined ? {} : _config$ios;

  if (Array.isArray(web.icons)) {
    return web.icons;
  }
  let icons = [];
  let icon;
  if (web.icon || config.icon) {
    icon = getAbsolutePath(web.icon || config.icon);
  } else {
    // Use template icon
    icon = options.templateIcon;
  }
  const destination = `assets/icons`;
  icons.push({ src: icon, size: ICON_SIZES, destination });
  const iOSIcon = config.icon || ios.icon;
  if (iOSIcon) {
    const iOSIconPath = getAbsolutePath(iOSIcon);
    icons.push({
      ios: true,
      sizes: 180,
      src: iOSIconPath,
      destination
    });
  }
  return icons;
}

function inferWebStartupImages(config = {}, getAbsolutePath, options) {
  const icon = config.icon;
  var _config$web2 = config.web;
  const web = _config$web2 === undefined ? {} : _config$web2;
  var _config$splash = config.splash;
  const splash = _config$splash === undefined ? {} : _config$splash,
        primaryColor = config.primaryColor;

  if (Array.isArray(web.startupImages)) {
    return web.startupImages;
  }

  var _web$splash = web.splash;
  const webSplash = _web$splash === undefined ? {} : _web$splash;

  let startupImages = [];

  let splashImageSource;
  const possibleIconSrc = webSplash.image || splash.image || icon;
  if (possibleIconSrc) {
    const resizeMode = webSplash.resizeMode || splash.resizeMode || 'contain';
    const backgroundColor = webSplash.backgroundColor || splash.backgroundColor || primaryColor || '#ffffff';
    splashImageSource = getAbsolutePath(possibleIconSrc);
    startupImages.push({
      resizeMode,
      color: backgroundColor,
      src: splashImageSource,
      supportsTablet: webSplash.supportsTablet === undefined ? true : webSplash.supportsTablet,
      orientation: web.orientation,
      destination: `assets/splash`
    });
  }
  return startupImages;
}

function ensurePWAConfig(appJSON, getAbsolutePath, options) {
  const config = applyWebDefaults(appJSON);
  if (getAbsolutePath) {
    config.web.icons = inferWebHomescreenIcons(config, getAbsolutePath, options);
    config.web.startupImages = inferWebStartupImages(config, getAbsolutePath, options);
  }
  return config;
}

function readConfigJson(projectRoot) {
  var _findConfigFile = findConfigFile(projectRoot);

  const configPath = _findConfigFile.configPath,
        configNamespace = _findConfigFile.configNamespace;


  let exp;
  let rootConfig;

  exp = require(configPath);

  if (configNamespace) {
    // if we're not using exp.json, then we've stashed everything under an expo key
    rootConfig = exp;
    exp = exp[configNamespace];
  }

  if (!rootConfig) {
    throw new Error('app.json could not be found at: ' + configPath);
  }

  return exp;
}